최초의 프로그램은 루틴(routine)이라고 불렸다.  
루틴은 주문서(혹은 명령어들)의 나열이었다. 루틴은 몇몇 데이터와 함께 처리 장치에 적재되고, 시간과 운이 따르는 경우 결과물이 나왔다.

하지만 단일 목록 형태로 루틴을 관리하는 것은 굉장히 어려웠다.  
동일한 명령어 목록이 여러 루틴에서 발견되기도 하고, 같은 루틴에서 같은 명령어 목록이 여러 번 나오기도 했다.  
그래서 서브루틴(subroutine)이 만들어졌다.  
그리고 유용한 여러 서브루틴을 묶어서 라이브러리라고 부르기 시작했다.  
각각의 서브 루틴은 호출 번호가 지정되었는데, 마치 도서관 책의 요청 번호와 같은 맥락이다.

그레이스 호퍼(Grace Murray Hopper)는 A-0이라고 명명된 루틴을 개발했고, 이것이 최초의 컴파일러다.  
컴파일러는 명령어 목록들과 호출 번호들, 그리고 서브루틴 라이브러리를 가지고 있는 테이프를 전달받아 처리했다.  
호출 번호와 연관된 서브루틴을 찾아서 새로운 프로그램을 집어넣었다.

도서관에서 책을 요청하는 것처럼 프로그램에서 서브루틴을 호출한다.  
서브루틴을 시작하거나 활성화하는 것이 아니라 '호출'한다.

function 연산자는 함수 객체를 만든다.  
function 연산자는 매개변수 목록과 문장 블록으로 구성된 함수 몸체를 전달받는다.  
매개변수 목록에 있는 각각의 이름은 함수 호출 시 인자 목록으로 전달되는 표현식을 통해 초기화될 변수들이다.  
각각의 이름 뒤에는 = 부호와 표현식이 올 수 있다.  
이 경우 인자로 전달되는 값이 undefined라면 대신 = 다음의 표현식 값이 초기화에 사용된다.

```js
function make_set(array, value = true) {
  // 문자열 배열에서 속성 이름을 가져와서 객체를 만든다.

  const object = Object.create(null);
  array.forEach(function (name) {
    object[name] = value;
  });
  return object;
}
```

## 호출

### 전개(spread)문과 나머지(rest)문

함수 객체는 인자 목록과 함께 호출되는데, 인자 목록에는 표현식이 없거나 한 개 이상의 표현식이 있을 수도 있으며, 각각은 쉼표(,)로 구분된다.  
각 표현식은 계산된 뒤 함수의 매개변수에 지정된다.  
인자 목록과 매개변수 목록은 길이가 같지 않을 수도 있다. 매개변수보다 긴 인자들은 함수에서 무시된다.  
빠진 인자는 매개변수에 대해 undefined 값을 지정하게 된다.

확산 연산자(...)는 인자 목록이나 매개변수 목록에서 사용할 수 있다.  
확산 연산자를 **인자 목록**에서 쓰면 **전개(spread)문**이라고 부른다.
배열을 받아서 전개함으로써 배열의 각 요소가 구분된 인자처럼 전달되도록 해 준다.  
**매개변수 목록**에서 쓰면 **나머지(rest)문**이 된다.
인자의 나머지가 하나의 배열로 묶여서 해당 매개변수 이름과 연결된다.  
그래서 나머지문을 쓰는 매개변수는 매개변수 목록에서 반드시 마지막에 나와야 한다.  
나머지문을 써서 가변 인자를 처리할 수 있다.
